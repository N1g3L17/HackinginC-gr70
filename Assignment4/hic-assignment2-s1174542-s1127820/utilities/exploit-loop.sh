#!/bin/bash

#
# Source the shell-rc file if you want access to the functions therein.
# `.` is the shorthand command for sourcing a file,
# `./shell-rc` refers to the file `shell-rc` in the *current* directory `./`
#
. ./shell-rc

#
# NOTE: This is a rather quick-and-dirty *EXAMPLE* script to inspire
# you of how you *could* use shell scripting to make your life a bit
# easier during an attack. Don't just copy it blindly, it will probably break
# in fun and interesting ways.
# 
# This script assumes you build the attack string in an external file
# called `exploit.bin` in the same directory.
# 
# Between loop iterations you can remove and generate a new `exploit.bin`.
#
#
#
# Run as `./exploit-loop.sh 4 | ./buffer-loop` for 4 loop iterations.
# 
# Then build `exploit.bin` in a separate terminal, e.g.
# (spamf "%p " 50; revaddr 0x0000aabbccddeeff;) > exploit.bin
#
# Then press return in the terminal executing this script to input
# `exploit.bin` and go to the next loop iteration.

for i in $(seq 1 $1)
do

	echo >&2
	echo >&2

	# Note that this prompt may be interleaved with the vulnerable
	# program's output, and therefore not the last thing visible in
	# the terminal.
	read -p "Press enter to continue..."

	# This next echo statements end with >&2, which is some magic that
	# redirects the output to stderr, so that it does not interfere with
	# outputting stdout to the vulnerable program.
	# Tells you the size (in bytes) of the entire attack string.
	# Note that if it contains a newline (or a NULL for string handling
	# functions) it will not overflow that many bytes of buffer.
	echo "Attackstring is $(wc -c exploit.bin) bytes" >&2
	xxd exploit.bin >&2
	echo >&2
	echo >&2

	cat exploit.bin

	# We need to emit the newline to end gets' input, unless
	# this is already in exploit.bin
	printf "\n"

done

# Keep input open so that we don't immediately exit from the shell we spawned.
cat -

